import { NextRequest, NextResponse } from "next/server";
import { getArtifact } from "@/lib/vultr-artifacts";

/**
 * GET /api/chat/c1/artifacts/download/[artifactId]
 *
 * Downloads an artifact in the specified format.
 *
 * Query params:
 * - format: "html" | "json" (default: "html")
 * - key: Storage key (required if not using artifactId lookup)
 *
 * Note: PDF generation requires additional setup (puppeteer, etc.)
 * For now, we support HTML download which can be printed to PDF in browser.
 */

const CHAT_SERVICE_URL = process.env.NEXT_PUBLIC_CHAT_API_URL ||
  "https://svc-01kc6rbecv0s5k4yk6ksdaqyzk.01k66gywmx8x4r0w31fdjjfekf.lmapp.run";

/**
 * Extract user ID from JWT token
 */
function extractUserIdFromToken(authHeader: string | null): string | null {
  if (!authHeader?.startsWith("Bearer ")) return null;

  try {
    const token = authHeader.substring(7);
    const payload = JSON.parse(atob(token.split(".")[1]));
    return payload.sub || payload.userId || payload.user_id || null;
  } catch {
    return null;
  }
}

/**
 * Convert C1 DSL content to basic HTML for download
 * This is a simplified renderer - for full fidelity, use C1Component in browser
 */
function convertToHtml(content: string, title: string): string {
  // Basic HTML wrapper with print-friendly styles
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  <style>
    @media print {
      body { margin: 0; padding: 20px; }
      @page { margin: 1in; }
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
      color: #1a1a2e;
      background: #fff;
    }
    h1 { font-size: 2em; margin-bottom: 0.5em; color: #16213e; }
    h2 { font-size: 1.5em; margin-top: 1.5em; color: #16213e; border-bottom: 2px solid #e8e8e8; padding-bottom: 0.3em; }
    h3 { font-size: 1.25em; color: #0f3460; }
    p { margin: 1em 0; }
    ul, ol { margin: 1em 0; padding-left: 2em; }
    li { margin: 0.5em 0; }
    table { width: 100%; border-collapse: collapse; margin: 1em 0; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e8e8e8; }
    th { background: #f8f9fa; font-weight: 600; }
    .stat-block { display: inline-block; padding: 15px 20px; background: #f8f9fa; border-radius: 8px; margin: 5px; }
    .stat-value { font-size: 1.5em; font-weight: bold; color: #0f3460; }
    .stat-label { font-size: 0.9em; color: #666; }
    blockquote { border-left: 4px solid #0f3460; margin: 1em 0; padding: 0.5em 1em; background: #f8f9fa; }
    .footer { margin-top: 2em; padding-top: 1em; border-top: 1px solid #e8e8e8; font-size: 0.9em; color: #666; }
  </style>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  <div class="content">
    ${content}
  </div>
  <div class="footer">
    <p>Generated by Hakivo Congressional Assistant</p>
    <p>Downloaded: ${new Date().toLocaleDateString()}</p>
  </div>
  <script>
    // Hint for PDF printing
    if (window.location.search.includes('print=true')) {
      window.print();
    }
  </script>
</body>
</html>`;
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ artifactId: string }> }
) {
  try {
    const { artifactId } = await params;
    const authHeader = req.headers.get("Authorization");
    const format = req.nextUrl.searchParams.get("format") || "html";
    const storageKey = req.nextUrl.searchParams.get("key");

    // Authentication is optional for download (allows sharing)
    // but we need either a storage key or the user to be authenticated
    const userId = extractUserIdFromToken(authHeader);

    console.log("[Artifacts Download] Request:", { artifactId, format, hasKey: !!storageKey, userId });

    let artifactContent: string | undefined;
    let artifactTitle = "Hakivo Document";
    let artifactType: string | undefined;

    // If storage key is provided, fetch directly from Vultr
    if (storageKey) {
      const result = await getArtifact(storageKey);
      if (!result.success || !result.content) {
        return NextResponse.json(
          { error: result.error || "Artifact not found" },
          { status: 404 }
        );
      }
      artifactContent = result.content;
      artifactTitle = result.metadata?.title || artifactTitle;
      artifactType = result.metadata?.type;
    }
    // Otherwise, try to lookup the storage key from the database
    else if (userId) {
      try {
        const docResponse = await fetch(
          `${CHAT_SERVICE_URL}/documents/${artifactId}`,
          {
            headers: {
              Authorization: authHeader || "",
            },
          }
        );

        if (docResponse.ok) {
          const doc = await docResponse.json();
          if (doc.storageKey) {
            const result = await getArtifact(doc.storageKey);
            if (result.success && result.content) {
              artifactContent = result.content;
              artifactTitle = doc.title || result.metadata?.title || artifactTitle;
              artifactType = doc.type || result.metadata?.type;
            }
          }
        }
      } catch (dbError) {
        console.warn("[Artifacts Download] Database lookup failed:", dbError);
      }
    }

    if (!artifactContent) {
      return NextResponse.json(
        { error: "Artifact not found. Please provide a valid storage key or ensure you're authenticated." },
        { status: 404 }
      );
    }

    // Return based on format
    if (format === "json") {
      return NextResponse.json({
        artifactId,
        title: artifactTitle,
        type: artifactType,
        content: artifactContent,
      });
    }

    // Default: HTML format (can be printed to PDF in browser)
    const html = convertToHtml(artifactContent, artifactTitle);
    const filename = `${artifactTitle.replace(/[^a-z0-9]/gi, "_").substring(0, 50)}.html`;

    return new NextResponse(html, {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Content-Disposition": `attachment; filename="${filename}"`,
      },
    });
  } catch (error) {
    console.error("[Artifacts Download] Error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Internal server error" },
      { status: 500 }
    );
  }
}
