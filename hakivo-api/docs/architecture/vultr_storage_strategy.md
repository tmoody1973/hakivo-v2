# Vultr Object Storage Integration Strategy

## Overview

**Hackathon Requirement:** Hakivo must use Vultr services. Vultr Object Storage provides S3-compatible object storage for audio files generated by ElevenLabs, with global CDN distribution for fast playback.

## Why Vultr Object Storage?

1. **Hackathon Requirement**: Must demonstrate Vultr service integration
2. **S3-Compatible**: Works with AWS SDK (@aws-sdk/client-s3)
3. **Global CDN**: Fast audio delivery worldwide
4. **Cost-Effective**: Competitive pricing for large file storage
5. **Scalable**: Handles 1000s of concurrent brief generations

## Storage Architecture

### File Organization

```
hakivo-briefs/
  ├── daily/
  │   ├── 2024/
  │   │   ├── 01/
  │   │   │   ├── 15/
  │   │   │   │   ├── usr_123abc_daily_20240115.mp3
  │   │   │   │   ├── usr_456def_daily_20240115.mp3
  │   │   │   ├── 16/
  │   │   │   │   ├── usr_123abc_daily_20240116.mp3
  │   ├── 2025/
  │       ├── 01/
  ├── weekly/
  │   ├── 2024/
  │   │   ├── W03/
  │   │   │   ├── usr_123abc_weekly_W03_2024.mp3
  │   │   │   ├── usr_456def_weekly_W03_2024.mp3
  │   │   ├── W04/
  │   ├── 2025/
  │       ├── W01/
```

### File Naming Convention

```typescript
// Daily brief
`daily/${year}/${month}/${day}/${userId}_daily_${YYYYMMDD}.mp3`

// Weekly brief
`weekly/${year}/W${weekNumber}/${userId}_weekly_W${weekNumber}_${year}.mp3`

// Example
`daily/2024/01/15/usr_123abc_daily_20240115.mp3`
`weekly/2024/W03/usr_123abc_weekly_W03_2024.mp3`
```

## SDK Configuration

### Installation

```bash
npm install @aws-sdk/client-s3
```

### S3 Client Setup

```typescript
// src/vultr-storage-client/index.ts
import { Service } from '@liquidmetal-ai/raindrop-framework';
import { Env } from './raindrop.gen';
import { S3Client, PutObjectCommand, GetObjectCommand, HeadObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export default class VultrStorageClient extends Service<Env> {
  private s3: S3Client;
  private bucketName: string;

  constructor(ctx: ExecutionContext, env: Env) {
    super(ctx, env);

    this.bucketName = env.VULTR_BUCKET_NAME;

    this.s3 = new S3Client({
      region: 'auto',  // Vultr auto-detects region
      endpoint: `https://${env.VULTR_ENDPOINT}`,
      credentials: {
        accessKeyId: env.VULTR_ACCESS_KEY,
        secretAccessKey: env.VULTR_SECRET_KEY
      },
      forcePathStyle: false  // Use virtual-hosted-style URLs
    });
  }

  async fetch(request: Request): Promise<Response> {
    return new Response('Not Implemented', { status: 501 });
  }

  /**
   * Upload audio file to Vultr Object Storage
   * Returns public CDN URL
   */
  async uploadAudio(params: {
    userId: string;
    briefType: 'daily' | 'weekly';
    audioBuffer: ArrayBuffer;
    date: Date;
    contentType?: string;
  }): Promise<UploadResult> {
    const { userId, briefType, audioBuffer, date, contentType = 'audio/mpeg' } = params;

    // Generate file key
    const fileKey = this.generateFileKey(userId, briefType, date);

    this.env.logger.info('Uploading audio to Vultr', {
      userId,
      briefType,
      fileKey,
      sizeBytes: audioBuffer.byteLength
    });

    try {
      // Upload to Vultr Object Storage
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey,
        Body: audioBuffer,
        ContentType: contentType,
        CacheControl: 'public, max-age=31536000',  // 1 year cache
        Metadata: {
          userId,
          briefType,
          uploadDate: date.toISOString()
        }
      });

      const startTime = Date.now();
      await this.s3.send(command);
      const uploadTime = Date.now() - startTime;

      // Generate public URL
      const publicUrl = `https://${this.bucketName}.${this.env.VULTR_ENDPOINT}/${fileKey}`;

      // Log upload for monitoring
      await this.logUpload({
        fileKey,
        sizeBytes: audioBuffer.byteLength,
        uploadTime,
        userId,
        briefType
      });

      this.env.logger.info('Audio uploaded successfully', {
        fileKey,
        publicUrl,
        uploadTime,
        sizeBytes: audioBuffer.byteLength
      });

      return {
        url: publicUrl,
        key: fileKey,
        bucket: this.bucketName,
        sizeBytes: audioBuffer.byteLength,
        uploadedAt: Date.now()
      };

    } catch (error) {
      this.env.logger.error(error as Error, {
        service: 'vultr-storage',
        operation: 'uploadAudio',
        fileKey,
        userId,
        briefType
      });
      throw error;
    }
  }

  /**
   * Generate presigned URL for temporary access
   * Useful for private/authenticated downloads
   */
  async getPresignedUrl(fileKey: string, expiresIn: number = 3600): Promise<string> {
    const command = new GetObjectCommand({
      Bucket: this.bucketName,
      Key: fileKey
    });

    const presignedUrl = await getSignedUrl(this.s3, command, { expiresIn });

    this.env.logger.info('Generated presigned URL', {
      fileKey,
      expiresIn
    });

    return presignedUrl;
  }

  /**
   * Check if file exists in Vultr Object Storage
   */
  async fileExists(fileKey: string): Promise<boolean> {
    try {
      const command = new HeadObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey
      });

      await this.s3.send(command);
      return true;
    } catch (error: any) {
      if (error.name === 'NotFound') {
        return false;
      }
      throw error;
    }
  }

  /**
   * Get file metadata without downloading
   */
  async getFileMetadata(fileKey: string): Promise<FileMetadata> {
    const command = new HeadObjectCommand({
      Bucket: this.bucketName,
      Key: fileKey
    });

    const response = await this.s3.send(command);

    return {
      contentType: response.ContentType || '',
      contentLength: response.ContentLength || 0,
      lastModified: response.LastModified?.getTime() || 0,
      metadata: response.Metadata || {}
    };
  }

  /**
   * Generate file key from brief parameters
   */
  private generateFileKey(userId: string, briefType: 'daily' | 'weekly', date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    if (briefType === 'daily') {
      const dateStr = `${year}${month}${day}`;
      return `daily/${year}/${month}/${day}/${userId}_daily_${dateStr}.mp3`;
    } else {
      // Weekly: Use ISO week number
      const weekNumber = this.getWeekNumber(date);
      return `weekly/${year}/W${String(weekNumber).padStart(2, '0')}/${userId}_weekly_W${String(weekNumber).padStart(2, '0')}_${year}.mp3`;
    }
  }

  /**
   * Get ISO week number
   */
  private getWeekNumber(date: Date): number {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
  }

  /**
   * Log upload for cost monitoring
   */
  private async logUpload(params: {
    fileKey: string;
    sizeBytes: number;
    uploadTime: number;
    userId: string;
    briefType: string;
  }) {
    await this.env.APP_DB.exec(`
      INSERT INTO api_usage_logs (id, service, endpoint, response_time, status, created_at, metadata)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [
      crypto.randomUUID(),
      'vultr-storage',
      'putObject',
      params.uploadTime,
      200,
      Date.now(),
      JSON.stringify({
        fileKey: params.fileKey,
        sizeBytes: params.sizeBytes,
        sizeMB: (params.sizeBytes / 1024 / 1024).toFixed(2),
        userId: params.userId,
        briefType: params.briefType
      })
    ]);
  }
}

interface UploadResult {
  url: string;
  key: string;
  bucket: string;
  sizeBytes: number;
  uploadedAt: number;
}

interface FileMetadata {
  contentType: string;
  contentLength: number;
  lastModified: number;
  metadata: Record<string, string>;
}
```

## Usage in Brief Generator

```typescript
// src/brief-generator/index.ts

async generateBrief(briefRequest: BriefRequest) {
  // 1. Collect news and bill updates
  const newsArticles = await this.collectNews(briefRequest.userId, briefRequest.type);
  const billUpdates = await this.collectBillUpdates(briefRequest.userId);

  // 2. Generate script and article with Claude
  const { script, article } = await this.env.CLAUDE_CLIENT.generateContent({
    newsArticles,
    billUpdates,
    briefType: briefRequest.type
  });

  // 3. Synthesize audio with ElevenLabs
  const audioBuffer = await this.env.ELEVENLABS_CLIENT.synthesizeDialogue({
    script,
    voices: ['Brian', 'Sarah']  // Dual-voice podcast
  });

  // 4. Upload audio to Vultr Object Storage
  const uploadResult = await this.env.VULTR_STORAGE_CLIENT.uploadAudio({
    userId: briefRequest.userId,
    briefType: briefRequest.type,
    audioBuffer,
    date: new Date()
  });

  // 5. Store brief metadata in SQL
  await this.env.APP_DB.exec(`
    INSERT INTO briefs (id, user_id, type, title, date, status, script, article, audio_url, file_size, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `, [
    briefRequest.briefId,
    briefRequest.userId,
    briefRequest.type,
    `Your ${briefRequest.type === 'daily' ? 'Daily' : 'Weekly'} Brief - ${new Date().toLocaleDateString()}`,
    Date.now(),
    'completed',
    script,
    article,
    uploadResult.url,  // Vultr CDN URL
    uploadResult.sizeBytes,
    Date.now()
  ]);

  this.env.logger.info('Brief generation completed', {
    briefId: briefRequest.briefId,
    userId: briefRequest.userId,
    audioUrl: uploadResult.url,
    fileSizeMB: (uploadResult.sizeBytes / 1024 / 1024).toFixed(2)
  });

  return {
    briefId: briefRequest.briefId,
    audioUrl: uploadResult.url,
    duration: this.calculateDuration(audioBuffer),
    status: 'completed'
  };
}
```

## Cost Estimates

### Vultr Object Storage Pricing

**Storage:** $5/TB/month ($0.005/GB/month)
**Bandwidth:** $10/TB ($0.01/GB)

### Monthly Cost Calculation (1000 users)

**Storage:**
- Daily briefs: 7 MB × 30 days × 1000 users = 210 GB
- Weekly briefs: 20 MB × 4 weeks × 1000 users = 80 GB
- **Total storage**: 290 GB
- **Storage cost**: 290 GB × $0.005 = **$1.45/month**

**Bandwidth** (assuming 2 plays per brief):
- Daily downloads: 7 MB × 30 × 1000 × 2 = 420 GB
- Weekly downloads: 20 MB × 4 × 1000 × 2 = 160 GB
- **Total bandwidth**: 580 GB
- **Bandwidth cost**: 580 GB × $0.01 = **$5.80/month**

**Total Vultr Cost: ~$7.25/month for 1000 users**

## Error Handling

```typescript
try {
  const uploadResult = await vultrClient.uploadAudio({...});
  return uploadResult;
} catch (error) {
  if (error.name === 'NoSuchBucket') {
    this.env.logger.error('Vultr bucket does not exist', {
      bucket: this.bucketName
    });
    // Create bucket or use fallback
  } else if (error.name === 'NetworkingError') {
    // Retry with exponential backoff
    await this.retryWithBackoff(() => vultrClient.uploadAudio({...}));
  } else {
    throw error;
  }
}
```

## Monitoring & Analytics

Track uploads, storage usage, and bandwidth:

```sql
SELECT
  DATE(created_at) as date,
  COUNT(*) as uploads,
  SUM(CAST(json_extract(metadata, '$.sizeBytes') AS INTEGER)) as total_bytes,
  AVG(response_time) as avg_upload_time
FROM api_usage_logs
WHERE service = 'vultr-storage'
  AND created_at >= datetime('now', '-30 days')
GROUP BY DATE(created_at)
ORDER BY date DESC;
```

## CDN Configuration

Vultr Object Storage includes automatic CDN:
- **Global edge locations**: Fast delivery worldwide
- **Cache-Control headers**: Set to 1 year for immutable audio files
- **HTTPS by default**: Secure delivery
- **No additional cost**: CDN included in storage pricing

## Security

### Public vs Private Access

```typescript
// Public URLs (default)
const publicUrl = `https://${bucket}.${endpoint}/${key}`;

// Presigned URLs for temporary access (if needed)
const presignedUrl = await vultrClient.getPresignedUrl(key, 3600);
```

### Access Control

```typescript
// Set bucket policy for public read access to audio files
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "PublicReadGetObject",
      "Effect": "Allow",
      "Principal": "*",
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::hakivo-briefs/*"
    }
  ]
}
```

## Summary

**Integration Points:**
- ✅ vultr-storage-client service for S3-compatible uploads
- ✅ brief-generator uploads MP3 files after ElevenLabs synthesis
- ✅ Public CDN URLs stored in briefs table
- ✅ Global CDN for fast playback
- ✅ Cost-effective: ~$7.25/month for 1000 users

**File Organization:**
- Daily briefs: `daily/YYYY/MM/DD/{userId}_daily_YYYYMMDD.mp3`
- Weekly briefs: `weekly/YYYY/W{weekNum}/{userId}_weekly_W{weekNum}_YYYY.mp3`

**Hackathon Compliance:**
- ✅ Demonstrates Vultr service integration
- ✅ S3-compatible API usage
- ✅ Scalable storage solution
- ✅ Production-ready architecture
